# 신뢰성 보장

- 카프카는 파티션 안의 메시지들 간에 순서를 보장한다. 만약 메시지 A 다음에 B가 쓰여졌다면, 동일한 프로듀서가 동일한 파티션에 썼을 경우, 카프카는 B의 오프셋이 A보다 큰 것을 보장한다. 컨슈머 역시 A를 읽어온 다음에 B를 읽게 된다.
- 클라이언트가 쓴 메시지는 모든 인-싱크 레플리카의 파티션에 쓰여진 뒤에야 커밋된 것으로 간주된다. 프로듀서는 메시지가 완전히 커밋된 다음 응답이 올지, 리더에게 쓰여진 다음 응답이 올지 아니면 네트워크로 전송된 다음 바로 응답이 올지를 선택할 수 있다.
- 커밋된 메시지들은 최소 1개의 작동 가능한 레플리카가 남아 있는 한 유실되지 않는다.
- 컨슈머는 커밋된 메시지만 읽을 수 있다.

<br>
<hr>

# 복제

카프카의 복제 메커니즘은 파티션별로 다수의 레플리카를 유지한다는 특성과 함께 카프카의 신뢰성 보장의 핵심이라고 할 수 있다. <br>
하나의 메시지를 여러 개의 레플리카에 씀으로써 카프카는 크래시가 나더라도 메시지의 지속성을 유지한다.

> 하나의 파티션은 하나의 디스크에 저장된다. <br>
> 카프카는 파티션에 저장된 이벤트들의 순서를 보장하며, 파티션은 온라인 상태거나 오프라인 상태일 수 있다. <br>
> 각 파티션은 다수의 레플리카를 가질 수 있으며, 그중 하나가 리더가 된다. <br>
> 모든 이벤트들은 리더 레플리카에 쓰여지며 리더 레플리카에서 읽혀진다. *(다른 레플리카들은 단순히 리더와 동기화를 맞추면서 최신 이벤트를 제 시간에 복사해 오기만 하면 된다.)* <br>
> 만약 리더가 작동 불능 상태가 되면, 인-싱크 레플리카 중 하나가 새 리더가 된다.


레플리카는 파티션의 리더 레플리카이거나 아니면 아래의 조건을 만족하는 팔로워 레플리카인 경우 인-싱크 상태인 것으로 간주된다.

- 주키퍼와의 활성 세션이 있다. 즉, 최근 6초 사이(설정 가능)에 주키퍼로 하트비트를 전송했다.
- 최근 10초 사이(설정 가능) 리더로부터 메시지를 읽어 왔다.
- 최근 10초 사이에 리더로부터 읽어 온 메시지들이 가장 최근 메시지이다.

만약 레플리카와 주키퍼 사이의 연결이 끊어지거나, 새 메시지를 읽어오길 중단하거나, 최근 10초 동 안의 업데이트 내역을 따라오지 못한다거나 할 경우 레플리카는 아웃-오브-싱크 상태로 간주된다. <br>
동기화가 풀린 레플리카는 주키퍼와 다시 연결되어 리더 파티션에 쓰여진 가장 최근 메시지까지를 따라잡으면 다시 인-싱크 레플리카가 된다.

동기화가 살짝 늦은 인-싱크 레플리카는 프로듀서와 컨슈머를 느리게 만들 수 있다. <br>
왜냐하면 프로 듀서와 컨슈머는 메시지가 커밋되기 전, 모든 인-싱크 레플리카가 해당 메시지를 받을 때까지 기다려야 하기 때문이다. <br>
만약 인-싱크 레플리카 수가 줄어들면 파티션의 실질적인 복제 팩터가 줄어들면서 중단 시간이 길어지 거나 데이터가 유실될 위험성은 높아진다.

<br>
<hr>

# 브로커 설정

메시지 저장 신뢰성 관련된 카프카의 작동을 변경시키는 브로커의 설정 매개변수는 세 개가 있다. <br>
이들은 브로커 단위에서 적용되어 시스템 안의 모든 토픽들을 제어할 수도 있고 토픽 단위에서 적용되어 특정 토픽의 작동을 제어할 수도 있다. <br>
**토픽 단위에서 신뢰성 트레이드오프를 제어할 수 있다는 것은 신뢰성이 필요한 토픽과 아닌 토픽을 같은 카프카 클러스터에 저장할 수 있음을 의미한다.**

## 복제 팩터

**토픽 단위 설정은 replication.factor에, 자동으로 생성되는 토픽들에 적용되는 브로커 단위 설정 은 default.replication.factor 설정에 잡아준다.**

복제 팩터가 N이면 N-1개의 브로커가 중단되더라도 토픽의 데이터를 읽거나 쓸 수 있다. <br>
따라서 복제 팩터가 클수록 가용성과 신뢰성은 늘어나고 장애가 발생할 가능성은 줄어든다. <br>
반대로 복제 팩터 가 N이라는 것은 최소한 N개의 브로커가 필요할 뿐더러 N개의 복사본을 저장해야 하므로 N배의 디스크 공간이 필요하다는 얘기도 된다.
**가용성과 하드웨어 사용량 사이에 트레이드오프가 있는 것이다.**

## 언클린 리더 선출

**이 설정은 브로커 단위에서만 가능하고,  매개변수 이름은 unclean.leader.election.enable이고 기본값은 false다.**

파티션의 리더가 더 이상 사용 가능하지 않을 경우 인-싱크 레플리카 중 하나가 새 리더가 된다. <br>
커밋된 데이터에 아무런 유실이 없음을 보장한다는 점에서 이러한 리더 선출을 **클린**하다고 부른다.

> 만약 작동 불능에 빠진 리더 외에 인-싱크 레플리카가 없다면 <br>
> 우리가 아웃-오브-싱크 레플리카가 리더가 될 수 있도록 허용할 경우 데이터 유실과 일관성 깨짐의 위험성이 있다.  <br>
> 그렇지 않을 경우, 파티션이 다시 온라인 상태가 될 때까지 원래 리더가 복구되는 것을 기다려야 하는 만큼 가용성은 줄어든다.

unclean.leader.election.enable 설정의 기본값은 false인데, 아웃-오브-싱크 레플리카는 리더가 될 수 없도록 되어 있는 것이다. <br>
데이터 유실에 있어 가장 좋은 보장을 제공하는 만큼 이것은 가장 안전한 옵션이다.

## 최소 인-싱크 레플리카

**토픽과 브로커 단위 모두 min.insync.replicas 설정에서 잡아줄 수 있다.**

토픽당 3개의 레플리카를 설정해주었더라도 인-싱크 레플리카는 하나만 남을 수도 있다. <br>
만약 이 레플리카가 작동 불능에 빠질 경우, 가용성과 일관성 사이에서 하나를 골라야 할 수 있다. <br>
카프카가 보장하는 신뢰성에 따르면, 데이터는 모든 인-싱크 레플리카에 쓰여진 시점에서 커밋된 것으로 간주되어서, 한 개의 레플리카만 남아있어도 이 레플리카가 작동 불능에 빠지면 데이터는 유실 될 수 있다.

커밋된 데이터를 2개 이상의 레플리카에 쓰고자 한다면, 인-싱크 레플리카의 최소값을 더 높게 잡아 줄 필요가 있다. <br>
만약 토픽에 레플리카가 3개 있고 min.insync.replicas를 2로 잡아 줬다면 프로듀서들은 3개의 레플리카 중 최소 2개가 인-싱크 상태인 파티션에만 쓸 수 있다.

## 레플리카를 인-싱크 상태로 유지하기

**아웃-오브-싱크 레플리카는 전반적인 신뢰성을 낮추므로 가능한 한 피할 필요가 있다.**

레플리카가 아웃-오브-싱크 상태가 될 수 있는 두 가지 이유를 위해 *(주키퍼와의 연결이 끊어지거나, 리더 업데이트 내역을 따라가는 데 실패해서 복제 랙이 발생)* <br>
카프카는 카프카 클러스터의 민감도를 조절할 수 있는 브로커 설정을 가지고 있다.

**zookeeper.session.timeout.ms**는 카프카 브로커가 주키퍼로 하트비트 전송을 멈출 수 있는 최대 시간을 정의한다. <br>
이 간격 안에만 하트비트를 보내면 주키퍼는 브로커가 죽었다고 판단하지 않으므로 클러스터에서 제외하지도 않는다.

만약 레플리카가 **replica.lag.time.max.ms**에 설정된 값보다 더 오랫동안 리더로부터 데이터를 읽어 오지 못하거나, 리더에 쓰여진 최신 메시지를 따라잡지 못하는 경우 동기화가 풀린 상태가 된다. (아웃-오브-싱크) <br>
이 설정은 컨슈머의 최대 지연에 영향을 주는데, 메시지가 모든 레플리카에 도착해서 컨슈머가 이 메시지를 읽을 수 있게 되는 데 최대 **replica.lag.time.max.ms**초가 걸릴 수 있다.

<br>
<hr>

# 신뢰성 있는 시스템에서 프로듀서 사용하기

## 응답 보내기

### acks=0

프로듀서가 네트워크로 메시지를 전송한 시점에서 메시지가 카프카에 성공적으로 쓰여진 것으로 간주된다. <br>
우리가 전송하는 객체가 직렬화될 수 없거나 네트워크 카드가 오작동할 경우 에러를 받겠지만, 파티션이 오프라인이거나, 리더 선출이 진행중이거나, 심지어 전체 카프카 클러스터가 작동 불능인 경우 에러가 발생하지 않을 것이다.

### acks=1

리더가 메시지를 받아서 파티션 데이터 파일에 쓴 직후 응답 또는 에러를 보낸다는 것을 의미한다. <br>
만약 일부 메시지가 리더에 성공적으로 쓰여져서 클라이언트로 응답이 간 상태에서 미처 팔로워로 복제가 완료되기 전에 리더가 정지하거나 크래쉬 날 경우 데이터가 유실될 수 있다.

### acks=all

리더가 모든 인-싱크 레플리카가 메시지를 받아갈 때까지 기다렸다가 응답하거나 에러를 보낸다는 것을 의미한다. <br>
이것은 가장 안전한 옵션이기도 한데, 프로듀서는 메시지가 완전히 커밋될 때까지 계속해서 메시지를 재전송한다.

## 프로듀서 재시도 설정하기

프로듀서는 재시도 가능한 에러를 처리할 수 있다. <br>
프로듀서가 브로커에 메시지를 전송하면 브로커는 성공 혹은 에러 코드를 리턴할 수 있는데, 에러 코드는 두 부류로 나뉘어진다. *(전송을 재시도하면 해결될 수 있는 것과 아닌 것)* <br>
예를 들어, 브로커가 LEADER_NOT_AVAILABLE 에러를 리턴하면 프로듀서는 전송을 재시도할 수 있다. <br>
만약 브로커가 INVALID_CONFIG 예외를 리턴할 경우, 같은 메시지를 재전송한다고 해서 설정이 변경되지는 않는다. 이것이 재시도 불가능한 에러의 한 예이다.

> 일반적으로, 메시지가 유실되지 않는 것이 목표일 경우, 가장 좋은 방법은 재시도 가능한 에러가 발생했을 경우 프로듀서가 계속해서 메시지 전송을 재시도하도록 설정하는 것이다. <br>
> 그리고 재시도에 가장 좋은 방법은 재시도 수를 기본 설정값(MAX_INT)로 두고 메시지 전송을 포기할 때까지 대기할 수 있는 시간을 지정하는 delivery.timeout.ms를 최댓값으로 설정하는 것이다. 

<br>
<hr>

# 신뢰성 있는 시스템에서 컨슈머 사용하기

컨슈머는 카프카에 커밋된 데이터만 읽을 수 있다. 즉, 모든 인-싱크 레플리카에 쓰여진 다음부터 읽을 수 있는 것이다. *(컨슈머는 일관성이 보장되는 데이터만 읽는다.)* <br>
컨슈머가 해야 할 일은 어느 메시지까지를 읽었고 어디까지는 읽지 않았는지를 추적하는 것이다. 이것은 메시지를 읽는 도중에 누락되지 않게 하기 위해서 필수적이다.

파티션으로부터 데이터를 읽어 올 때, 컨슈머는 메시지를 배치 단위로 읽어온 뒤 배치별로 마지막 오프셋을 확인한 뒤, 브로커로부터 받은 마지막 오프셋 값에서 시작하는 다른 메시지 배치를 요청한다. <br>
이렇게 함으로써 카프카 컨슈머는 메시지 누락 없이, 언제나 새로운 데이터를 올바른 순서로 읽어올 수 있다.

> 특정 카프카 컨슈머가 작동을 정지하면, 또 다른 컨슈머 입장에서는 어디서부터 작업을 재개해야 할지 알아야 할 필요가 있다. <br>
> 읽고 있는 각 파티션에 대해 어디까지 읽었는지를 저장해 둬야 해당 컨슈머나 다른 컨슈머가 재시작한 뒤에도 어디서부터 작업을 계속해야 할지 알 수 있기 때문에, **오프셋을 커밋**해야 한다.

## 신뢰성 있는 처리를 위해 중요한 컨슈머 설정

신뢰성을 갖는 컨슈머를 설정하기 위해 알아두어야 하는 컨슈머 속성은 다음과 같이 네 개가 있다.

### group.id

만약 같은 그룹 ID를 갖는 두 개의 컨슈머가 같은 토픽을 구독할 경우, 각각의 컨슈머에는 해당 토픽 전체 파티션의 서로 다른 부분집합이 할당되므로 각각은 서로 다른 부분의 메시지만을 읽게 된다. <br>
만약 컨슈머가 구독한 토픽의 모든 메시지를 읽어야 한다면 고유한 그룹 ID가 필요할 것이다.

### auto.offset.reset

커밋된 오프셋이 없을 때나 컨슈머가 브로커에 없는 오프셋을 요청할 때 컨슈머가 어떻게 해야 할 지를 결정한다.

만약 **earliest** 옵션을 사용한다면 유효한 오프셋이 없는 한 컨슈머는 파티션의 맨 앞에서부터 읽기를 시작하게 된다. <br>
이렇게 하면 컨슈머는 많은 메시지들을 중복 처리하게 될 수 있지만, 데이 터 유실은 최소화할 수 있다.

**latest**를 사용한다면 컨슈머는 파티션의 끝에서부터 읽기를 시작한다. 중복 처리는 최소화하지만, 컨슈머가 일부 메시지는 누락할 것이 거의 확실하다.

### enable.auto.commit

일정한 시간에 맞춰 컨슈머가 알아서 오프셋을 커밋하게 할 것인가, 아니면 코드에서 직접 오프셋을 커밋하게 할 것인가?

자동 오프셋 커밋의 주된 이점은 애플리케이션에서 컨슈머를 사용할 때 걱정거리가 한 개 준다는 점이다. <br>
자동 오프셋 커밋 기능의 주된 단점은 메시지 중복 처리를 우리가 제어할 수 없다는 점이겠다.

### auto.commit.interval.ms

만약 오프셋을 자동으로 커밋할 경우, 이 설정을 사용해서 커밋되는 주기를 설정할 수 있다. (기본값은 5초)
더 자주 커밋할수록 오버헤드 역시 늘어나지만 컨슈머가 정지했을 때 발생할 수 있는 중복의 수는 줄어든다.

## 컨슈머에서 명시적으로 오프셋 커밋하기

더 세밀한 제어가 필요해서 오프셋 커밋을 직접 수행하기로 했다면, 이러한 결정이 정확성과 성능에 미치는 영향에도 신경을 쓸 필요가 있다.

- 메시지 처리 먼저, 오프셋 커밋은 나중에
- 커밋 빈도는 성능과 크래시 발생시 중복 개수 사이의 트레이드오프다
- 정확한 시점에 정확한 오프셋을 커밋하자
- 리밸런스
- 컨슈머는 재시도를 해야 할 수도 있다
- 컨슈머가 상태를 유지해야 할 수도 있다

<br>
<hr>














